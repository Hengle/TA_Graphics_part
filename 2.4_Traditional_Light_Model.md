# 2.4 Traditional Light Model
## 传统光照模型
![image](https://user-images.githubusercontent.com/74708198/187167737-00fda841-63d4-4934-8e14-9c712d400e55.png)
## 1. Light source
### 1.1 Diffuse 
### 1.1.1 Lambert 
![image](https://user-images.githubusercontent.com/74708198/187170320-711db760-ff3d-49e5-a94d-9073da86245b.png)
![image](https://user-images.githubusercontent.com/74708198/187170639-25bc88f6-155e-4a9c-87d2-d9ef85f4d904.png)

* 补充：
  * 首先其中对应GAMES101中的辐射度量学中的一个概念
    * Irradiance翻译为辐照度
  * Lambert余弦定律结论：n（法线方向）和 l（光照方向）的夹角决定了明暗

### 1.1.2 Half-Lambert
### 1.2 Specular
### 1.2.1 Phong
![image](https://user-images.githubusercontent.com/74708198/187170713-fa98763a-bfe7-4504-a26a-0dede951d6d3.png)
* 用环境光照来代替间接光照
* 将几项加起来，形成一个相对比较完整的光照模型
* Phong模型的算法：
  * Phong = Pow(dot(v，r),_gloss)
### 1.2.2 Blinn-Phong


## 2. Environment Light
### 2.1 Diffuse
3Col-Ambient

### 2.2 Specular
### 2.2.1 Matcap

### 2.2.2 Cubemap

### 2.2.3 Fresnel


```HLSL
Shader "LearnZDTA/L9/OldSchool_Pro"
{
    Properties
    {
        [Header(texture)]
            _MainTex    ("RGB:基础颜色 A:环境遮罩", 2D)     = "white" {}
            _NormTex	("RGB:法线贴图", 2D)               = "bump" {}
            _SpecTex    ("RGB:高光颜色 A:高光次幂", 2D)      = "gray" {}
            _EmitTex    ("RGB:自发光贴图", 2d)                = "black" {}
            _Cubemap    ("RGB:环境贴图", cube)              = "_Skybox" {}
        [Header(Diffuse)]
            _MainCol("基本色",Color)                       = (0.5, 0.5, 0.5, 1.0)
            _EnvDiffInt ("环境漫反射强度",  Range(0, 1))    = 0.2
            _EnvUpCol   ("环境天顶颜色", Color)             = (1.0, 1.0, 1.0, 1.0)
            _EnvSideCol ("环境水平颜色", Color)             = (0.5, 0.5, 0.5, 1.0)
            _EnvDownCol ("环境地表颜色", Color)             = (0.0, 0.0, 0.0, 0.0)
        [Header(Specular)]
            _SpecPow    ("高光次幂",    Range(1, 90))       = 30
            _EnvSpecInt ("环境镜面反射强度", Range(0, 5))   = 0.2
            _FresnelPow ("菲涅尔次幂", Range(0, 5))         = 1
            _CubemapMip ("环境球Mip级别", Range(1, 7))          = 1
        [Header(Emission)]
            _EmitInt("自发光强度", range(1, 10)) = 1
        }
    SubShader
    {
        Tags {
            "RenderType"="Opaque"
        }
        
        Pass
        {
            Name "FORWARD"
            Tags { "LightMode"="ForwardBase" }
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include "UnityCG.cginc"
            #include "AutoLight.cginc"  //投影相关头文件
            #include "Lighting.cginc"

            #pragma multi_compile_fwdbase_fullshadows
            #pragma target 3.0
            //##声明面板参数##
            // Texture
            uniform sampler2D _MainTex;
            uniform sampler2D _NormTex;
            uniform sampler2D _SpecTex;
            uniform sampler2D _EmitTex;
            uniform samplerCUBE _Cubemap;
            // Diffuse
            uniform float3 _MainCol;
            uniform float _EnvDiffInt;
            uniform float3 _EnvUpCol;
            uniform float3 _EnvSideCol;
            uniform float3 _EnvDownCol;
            // Specular
            uniform float _SpecPow;
            uniform float _FresnelPow;
            uniform float _EnvSpecInt;
            uniform float _CubemapMip;
            // Emission
            uniform float _EmitInt;
            

            struct vertexInput
            {
                float4 vertex : POSITION;    //顶点信息
                float2 uv0 : TEXCOORD0;     //uv
                float4 normal : NORMAL;  //法线
                float4 tangent : TANGENT; //切线
                
            };

            struct vertexOutput
            {
                float4 pos : SV_POSITION;
                float2 uv0 : TEXCOORD0;
                float4 posWS    : TEXCOORD1;  // WS顶点位置
                float3 nDirWS   : TEXCOORD2;  // WS法线方向
                float3 tDirWS   : TEXCOORD3;  // WS切线方向
                float3 bDirWS   : TEXCOORD4;  // WS副切线方向
                LIGHTING_COORDS(5,6)          // 投影相关
            };

            vertexOutput vert (vertexInput v)
            {
                vertexOutput o = (vertexOutput)0;
                    o.pos = UnityObjectToClipPos( v.vertex ); //CS顶点信息
                    o.uv0 = v.uv0;  //法线
                    o.posWS = mul(unity_ObjectToWorld, v.vertex);    //WS顶点信息
                    o.tDirWS = normalize(mul(unity_ObjectToWorld, float4(v.tangent.xyz, 0.0)).xyz); //WS切线
                    o.nDirWS = UnityObjectToWorldNormal(v.normal);  //WS法线
                    o.bDirWS = normalize(cross(o.nDirWS, o.tDirWS) * v.tangent.w);  //WS副切线
                    //这里注意！因为b的计算用到了t和n，所以在写的时候要写在t和n之后
                    TRANSFER_VERTEX_TO_FRAGMENT(o)                  // 投影相关
                return o;
                
            }

            fixed4 frag (vertexOutput i) : SV_Target
            {
                 //向量准备
                 float3 nDirTS = UnpackNormal(tex2D(_NormTex, i.uv0)).rgb;
                 float3x3 TBN = float3x3(i.tDirWS, i.bDirWS, i.nDirWS);
                 float3 nDirWS = normalize(mul(nDirTS, TBN));
                 float3 vDirWS = normalize(_WorldSpaceCameraPos.xyz - i.posWS.xyz);//v方向=相机位置-所在位置
                 float3 vrDirWS = reflect(-vDirWS, nDirWS);
                 float3 lDirWS = _WorldSpaceLightPos0.xyz;
                 float3 lrDirWS = reflect(-lDirWS, nDirWS);
                
                 //中间计算
                 float ndotl = dot(nDirWS, lDirWS); //供Lambert使用
                 float vdotr = dot(vDirWS, lrDirWS); //Phong使用
                 float vdotn = dot(vDirWS, nDirWS); //Fresnel使用
                
                 //采样
                 float4 var_MainTex = tex2D(_MainTex, i.uv0);
                 float4 var_SpecTex = tex2D(_SpecTex, i.uv0);
                 float3 var_EmitTex = tex2D(_EmitTex, i.uv0).rgb;
                 float cubeMapMip = lerp(_CubemapMip, 0.0, var_SpecTex.a);//SpecTex的a通道理解为光滑度，达到光滑处反射比粗糙处清晰的效果
                 float3 var_Cubemap = texCUBElod(_Cubemap, float4(vrDirWS,cubeMapMip)).rgb;

                //光照计算
                     //DirectDif
                     float3 baseCol = var_MainTex.rgb * _MainCol;
                     float lambert = max(0.0,ndotl);
                     //DirectSpe
                     float specCol = var_SpecTex.rgb;
                     float specPow = lerp(1, _SpecPow, var_SpecTex.a);
                     float phong = pow(max(0.0, vdotr), specPow);
                     //DirTotal
                     float shadow = LIGHT_ATTENUATION(i);
                     float3 dirLighting = (baseCol * lambert + specCol * phong) * _LightColor0 * shadow;
                
                     //EnvDif
                     float upMask = max(0.0, nDirWS.g);          // 获取朝上部分遮罩
                     float downMask = max(0.0, -nDirWS.g);       // 获取朝下部分遮罩
                     float sideMask = 1.0 - upMask - downMask;   // 获取侧面部分遮罩
                     float3 envCol = _EnvUpCol * upMask +
                                 _EnvSideCol * sideMask +
                                 _EnvDownCol * downMask;     // 混合环境色
                     float3 envdif = envCol * baseCol * _EnvDiffInt;
                     //EnvSpe
                     float fresnel = pow(max(0.0, 1.0 - vdotn), _FresnelPow);
                     float3 envSpe = var_Cubemap * fresnel * _EnvSpecInt;    
                     //EnvTotal
                     float occlusion = var_MainTex.a;
                     float3 envLighting = (envdif + envSpe) * occlusion;
                
                     //自发光
                     float emitInt = _EmitInt * (sin(frac(_Time.z)) * 0.5 + 0.5);
                     float3 emission = var_EmitTex * emitInt;
                
                     //LightResult
                     float3 finaRBG = dirLighting + envLighting + emission;
                 //Result
                //return Phong;
                return float4(finaRBG,1.0);

            }
            ENDCG
        }
    }
    FallBack  "Diffuse"
}

```



