## 0. 渲染管线


## 1. 线代知识
* 向量
  * 是矢量，有方向，有大小
  * 向量的运算
    * 点乘 Dot product
      * 计算方式
        * 普遍情况： 点乘 = 两向量模长乘积 * cosθ
        * 单位向量情况： 点乘 = cosθ
      * 点乘的应用
        <br>① 找两向量夹角，点乘 = cosθ
        <br>② 找投影：b向量投影到a向量上 = b的模长*cosθ
        <br>③ 判断“前后”和“接近程度”：根据cosθ的正负和大小
    * 叉乘 cross product
      * 计算方式
        * 右手定则：食指向向量a，中指向向量b，大拇指就是叉乘的结果（normalize之后，忽略了长度）
      * 叉乘的应用
      <br>①右手坐标系：x轴和y轴叉乘得到z轴
      <br>②判断“左右”：a叉乘b结果为正 → b在a的左侧
      <br>③判断“内外”：给定三角形ABC，在忽略ABC点命名顺序的情况下：将三个顶点依次连成向量，如果点P都在这三个向量的左侧or右侧 → 点P在三角形内部
* 矩阵
  * 这里用《线代的本质》中的一句话理解：矩阵包含 着“线性变换”信息
    * 乘一个矩阵意味着做一次变换
  * 矩阵左乘的来源
    * 同来来自《线代的本质》，矩阵在此处和“函数”意义相同，接收输入，进行输出
    * 函数是f(x)，f放在变量x左边的
  * 矩阵的乘法：
    * m×n 和 n×p 的矩阵才可以乘，结果为m×p的矩阵
    * 计算方法：
      * 矩阵A * 矩阵B ，结果的第a行第b列的数 = 矩阵A的第a行 · 矩阵B的第b列
<br> ![image](https://user-images.githubusercontent.com/74708198/187121499-f1643712-e12e-442c-8c58-5bec518cbf5d.png)

  * 矩阵和向量的乘法：
    * 默认矩阵在左，向量看做m×1的矩阵
* 仿射变换
  * 仿射变换 = 线性变换 + 平移
* 齐次空间
  * 3×3矩阵并不能表示仿射变换，所以我们扩充了一维，这样就能表示了

### 1.1 MVP变换
![image](https://user-images.githubusercontent.com/74708198/187121864-b30fa0b9-f823-429a-bcd3-ad5145564284.png)
* M矩阵
  * 依次对顶点进行了：缩放→旋转→平移操作
* V矩阵
  * 观察空间是以Camera为中心的坐标系
  * V矩阵代表的变换过程可以这样理解：观察空间变换到世界空间的逆过程
    * 观察空间→世界空间 可以这样理解：让观察空间的坐标系原点和世界空间重合即可
    * 过程：先旋转，再平移
  * 求V矩阵 = 逆过程
    * 过程：平移 → 旋转 → z取反（Unity为左手坐标系）
* P矩阵
  * 不是真正的投影，而是为投影做准备（投影操作在后续）
  * 有正交和透视投影两种
  * 本质上对xyz分量进行了不同程度的缩放，方便裁剪
  * w是z分量取反，用来进行视锥体内的裁剪（如果在视锥体内，必定满足-w≤x≤w）
  * 应用了P矩阵之后的结果是转换到裁剪空间
  
  ## 2. 纹理知识
  * 纹理管线
  <br>![image](https://user-images.githubusercontent.com/74708198/187122022-232e40a0-18d5-48b7-83a6-ddde1e8b477e.png)
* 纹理映射
  * 将2D图像映射到3D模型上
* 寻址模式（Wrap Mode）
<br>![image](https://user-images.githubusercontent.com/74708198/187122056-d812c3a6-41cc-4709-a7a3-e449ade9444c.png)
* 纹理过大过小出现的问题及解决：
  * 纹理过小：
    * 问题：这个简单，因为精度不够，会失真
    * 解决：
      * 过滤机制（Filter Mode）
        * 将浮点型的像素坐标转换为整型
        * 最邻近、双线性插值、立方体卷积插值（双向三次插值）、Q光滑曲线插值
  * 纹理过大：
    * 问题：近处锯齿（走样），远处摩尔纹
    * 解决：
      * ①超采样：把每个像素细分成多个采样点（太耗）
      * ②Mipmap：对纹理进行预处理，预先生成一系列以2为倍数缩小的纹理序列，在采样纹理时根据图形的大小自动选择相近等级的Mipmap进行采样。
        * Mipmap总共有多少层：log2n层
        * Mipmap的存储量：比原来多1/3（整体的4/3）
        * Mipmap层级的计算方法：
        * 计算纹理坐标横向和纵向的偏导数（ddx，ddy），并取做大值delata
        * 最后来计算层数 = 0.5 * log2delta
<br>事实上确实是这么做的，例如OpenGL就是通过计算纹理坐标在纵向和横向的偏导数（并取最大值）来计算Mipmap的级别。
```HLSL
float MipmapLevel(vec2 texCoord)
{
    //
    //
    vec2 dx = dFdx(texCoord)
    vec2 dy = dFdy(texCoord)
    float delta = max(dot(dx, dx), dot(dy, dy));
    return 0.5 * log2(delta);
}
```
        
  * Mipmap看这位大佬的文章：Clawko：图形学底层探秘 - 纹理采样、环绕、过滤与Mipmap的那些事
  * **补充：不使用Mipmap会出现的一个问题**
    * 远处的精度比较高，会出现一种Pixel Shimmer/Sizzle的情况
    * 是因为贴图的像素比屏幕的像素更多
https://user-images.githubusercontent.com/74708198/187122484-de00f6d2-3c10-412a-8eb5-6e47aeb172ce.mp4
  * 纹理的优化手段
    * CPU优化手段-降低DrawCall
      * 纹理图集：一堆小纹理合成一个大的纹理
      * 纹理数组（Texture Array）
    * GPU优化手段-带宽入手
      * 纹理压缩：降低纹理占的内存









